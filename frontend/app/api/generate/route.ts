import { NextRequest, NextResponse } from 'next/server';
import { ConfigFormSchema } from '@/lib/validation';
import { ZodError } from 'zod';
import { generateSecureSecret, generatePassword, generateJWT, generateEnvFile, generateDockerCompose, generateDockerComposeOverride } from '@/lib/config-generator';
import type { GeneratedConfig } from '@/lib/types';

export const runtime = 'nodejs';

export async function POST(request: NextRequest) {
  try {
    // Determine generator site URL for headers (falls back to localhost)
    const proto = (request.headers.get('x-forwarded-proto') || 'http').replace(/[^a-z]+/gi, '');
    const host = request.headers.get('host') || 'localhost:3000';
    let generatorUrl = `${proto}://${host}`;

    // Prefer JSON body; fall back to formData if needed, and handle empty/malformed JSON safely
    let data: any = {};
    const contentType = (request.headers.get('content-type') || '').toLowerCase();

    if (contentType.includes('application/json')) {
      const raw = await request.text();
      if (raw && raw.trim().length > 0) {
        try {
          data = JSON.parse(raw);
        } catch {
          return NextResponse.json(
            { error: 'Invalid JSON body', message: 'Request body is not valid JSON.' },
            { status: 400 }
          );
        }
      } else {
        data = {};
      }
    } else if (contentType.includes('multipart/form-data') || contentType.includes('application/x-www-form-urlencoded')) {
      const formData = await request.formData();
      data = Object.fromEntries(formData as any);
    } else {
      // Unknown content-type: try formData first (will throw if not multipart), then JSON text as a last resort
      try {
        const formData = await request.formData();
        data = Object.fromEntries(formData as any);
      } catch {
        const raw = await request.text();
        if (raw && raw.trim().length > 0) {
          try {
            data = JSON.parse(raw);
          } catch {
            return NextResponse.json(
              { error: 'Unsupported body format', message: 'Provide application/json or form data.' },
              { status: 400 }
            );
          }
        } else {
          data = {};
        }
      }
    }

    // Coerce boolean-like strings for known fields
    const boolKeys = ['enable_dev_override', 'enable_vector', 'enable_logflare', 'enable_pgvector'] as const;
    for (const k of boolKeys) {
      if (typeof (data as any)[k] === 'string') {
        const v = ((data as any)[k] as string).toLowerCase();
        (data as any)[k] = v === 'true' || v === '1' || v === 'on' || v === 'yes';
      }
    }

    // Validate input using Zod schema
    const validatedData = ConfigFormSchema.parse(data);

    // Prefer canonical URL from the form if provided
    if (validatedData.canonical_url) {
      generatorUrl = validatedData.canonical_url;
    }

    // Generate missing secrets
    const config: GeneratedConfig = {
      project_name: validatedData.project_name,
      domain: validatedData.domain,
      email: validatedData.email,
      db_password: validatedData.db_password || generatePassword(32),
      jwt_secret: validatedData.jwt_secret || generateSecureSecret(64),
      anon_key: '',
      service_key: '',
    };

    // Generate JWT tokens
    const anonPayload = { role: 'anon', iss: 'supabase' };
    const servicePayload = { role: 'service_role', iss: 'supabase' };

    config.anon_key = validatedData.anon_key || await generateJWT(config.jwt_secret, anonPayload);
    config.service_key = validatedData.service_key || await generateJWT(config.jwt_secret, servicePayload);

    // Generate configuration files
    const envContent = generateEnvFile(config, {
      enable_vector: !!(validatedData as any).enable_vector,
      enable_logflare: !!(validatedData as any).enable_logflare,
      enable_pgvector: !!validatedData.enable_pgvector,
    });
    const composeContent = generateDockerCompose(config, {
      enable_vector: !!(validatedData as any).enable_vector,
      enable_logflare: !!(validatedData as any).enable_logflare,
      enable_pgvector: !!validatedData.enable_pgvector,
    });
    const overrideContent = generateDockerComposeOverride(config);

    // Optional extras
    let pgvectorSqlContent: string | undefined;
    let vectorConfigContent: string | undefined;
    if (validatedData.enable_pgvector) {
      pgvectorSqlContent = `-- 01-pgvector.sql
-- Generated by SBConfig: enable pgvector extension
-- Docs: https://github.com/pgvector/pgvector

CREATE EXTENSION IF NOT EXISTS vector;

-- Example embeddings table (adjust dimensions to your model)
-- Using OpenAI text-embedding-3-small (1536 dims) as an example.
CREATE TABLE IF NOT EXISTS public.documents (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  content text NOT NULL,
  metadata jsonb DEFAULT '{}'::jsonb,
  embedding vector(1536)
);

-- Optional: HNSW index for ANN search (requires pgvector >= 0.5.0)
-- Improves similarity search performance on large datasets
CREATE INDEX IF NOT EXISTS documents_embedding_hnsw
  ON public.documents USING hnsw (embedding vector_l2_ops);

-- Example similarity search query (top 5 by L2 distance):
-- SELECT id, content
-- FROM public.documents
-- ORDER BY embedding <-> '[0.1, 0.2, ...]'::vector
-- LIMIT 5;
`;
    }

    if ((validatedData as any).enable_vector) {
      const logflareEnabled = !!(validatedData as any).enable_logflare;
      vectorConfigContent = `# volumes/logs/vector.yml
# Vector configuration for collecting Docker container logs
# Docs: https://vector.dev/docs/

# Sources
sources:
  docker:
    type: docker_logs
    # Collect logs from all containers prefixed with supabase-
    include_containers: ["supabase-"]
    # Or list specific containers
    # include_containers: ["supabase-kong", "supabase-rest", "supabase-auth"]

# Transforms: parse JSON messages (if any), normalize fields, route by service, and build structured events
transforms:
  parse_json:
    type: remap
    inputs: ["docker"]
    source: |
      .service = .container_name
      .container_id = .container_id
      .host = .host
      if exists(.message) && is_string(.message) {
        parsed, err = parse_json(.message)
        if err == null {
          if exists(parsed.level) { .level = to_string(parsed.level) }
          if exists(parsed.msg) { .message = to_string(parsed.msg) }
          if exists(parsed.message) { .message = to_string(parsed.message) }
          .fields = parsed
        }
      }
  normalize:
    type: remap
    inputs: ["parse_json"]
    source: |
      .timestamp = now()
      .level = .level ?? "info"
      .service = replace!(.service, /^.*supabase-/, "")
      .message = to_string(.message ?? "")
  route_services:
    type: route
    inputs: ["normalize"]
    routes:
      rest: .service == "rest"
      auth: .service == "auth"
      kong: .service == "kong"
      storage: .service == "storage"
      realtime: .service == "realtime"
      functions: .service == "functions"
      others: true
  remap_struct:
    type: remap
    inputs: ["normalize"]
    source: |
      . = {
        service: to_string!(.service),
        level: to_string!(.level),
        message: to_string!(.message),
        timestamp: to_string!(.timestamp),
        fields: {
          host: to_string!(.host ?? ""),
          container_id: to_string!(.container_id ?? ""),
        }
      }

# Sinks
sinks:
  # All logs to console (pretty JSON)
  console:
    type: console
    inputs: ["normalize"]
    encoding:
      codec: json

  # Examples: per-service sinks (uncomment as needed)
  # console_rest:
  #   type: console
  #   inputs: ["route_services.rest"]
  #   encoding:
  #     codec: json
  # console_auth:
  #   type: console
  #   inputs: ["route_services.auth"]
  #   encoding:
  #     codec: json
  # console_storage:
  #   type: console
  #   inputs: ["route_services.storage"]
  #   encoding:
  #     codec: json
  # console_realtime:
  #   type: console
  #   inputs: ["route_services.realtime"]
  #   encoding:
  #     codec: json
  # console_functions:
  #   type: console
  #   inputs: ["route_services.functions"]
  #   encoding:
  #     codec: json

${logflareEnabled ? `  # Forward structured logs to Logflare (analytics service)
  logflare:
    type: http
    inputs: ["remap_struct"]
    uri: "http://analytics:4000/api/logs"
    compression: none
    encoding:
      codec: json
    headers:
      X-API-KEY: "${'{'}LOGFLARE_API_KEY{'}'}"
` : `  # Example: forward structured logs to Logflare HTTP endpoint (enable Logflare to use)
  # logflare:
  #   type: http
  #   inputs: ["remap_struct"]
  #   uri: "http://analytics:4000/api/logs"
  #   compression: none
  #   encoding:
  #     codec: json
  #   headers:
  #     X-API-KEY: "${'{'}LOGFLARE_API_KEY{'}'}"
`}`;
    }

    // Add file headers with generator and timestamp metadata
    const ts = new Date().toISOString();
    const envHeader = [
      '# ==================================',
      '# Generated by: SBConfig (Supabase Configuration Generator)',
      `# Creation Date: ${ts}`,
      `# Project: ${config.project_name}`,
      `# Website: ${generatorUrl}`,
      '# Docs: https://supabase.com/docs/guides/self-hosting',
      '# Notes: Keep this file secret. Do not commit to version control.',
      '# ==================================',
      ''
    ].join('\n');

    const composeHeader = [
      '# ==================================',
      '# Generated by: SBConfig (Supabase Configuration Generator)',
      `# Creation Date: ${ts}`,
      `# Project: ${config.project_name}`,
      `# Website: ${generatorUrl}`,
      '# File: docker-compose.yml',
      '# Docs: https://supabase.com/docs/guides/self-hosting',
      '# ==================================',
      ''
    ].join('\n');

    const overrideHeader = [
      '# ==================================',
      '# Generated by: SBConfig (Supabase Configuration Generator)',
      `# Creation Date: ${ts}`,
      `# Project: ${config.project_name}`,
      `# Website: ${generatorUrl}`,
      '# File: docker-compose.override.yml',
      '# Purpose: Development overrides (ports, volumes, verbosity).',
      '# Docs: https://docs.docker.com/compose/extends/',
      '# ==================================',
      ''
    ].join('\n');

    const envContentWithHeader = `${envHeader}${envContent}`;
    const composeContentWithHeader = `${composeHeader}${composeContent}`;
    const overrideContentWithHeader = `${overrideHeader}${overrideContent}`;

    const res = NextResponse.json({
      envContent: envContentWithHeader,
      composeContent: composeContentWithHeader,
      overrideContent: overrideContentWithHeader,
      pgvectorSqlContent,
      vectorConfigContent,
      config
    });
    // Prevent caching of secrets
    res.headers.set('Cache-Control', 'no-store');
    res.headers.set('Pragma', 'no-cache');
    return res;

  } catch (error: any) {
    // Sanitize error logging to avoid leaking secrets
    const safeError = {
      name: error?.name || 'Error',
      message: error?.message || 'Unknown error',
      stack: process.env.NODE_ENV === 'development' ? error?.stack : undefined,
    };
    console.error('Configuration generation failed:', safeError);

    if (error instanceof ZodError) {
      const errorMessages = error.errors.map((err) => `${err.path.join('.')}: ${err.message}`);
      return NextResponse.json({ error: 'Validation failed', errors: errorMessages }, { status: 400 });
    }
    // Fallback: some runtimes stringify ZodError into message
    try {
      const parsed = JSON.parse(error?.message || 'null');
      if (Array.isArray(parsed)) {
        const msgs = parsed.map((e: any) => `${(e.path || []).join('.')}: ${e.message}`);
        return NextResponse.json({ error: 'Validation failed', errors: msgs }, { status: 400 });
      }
    } catch {}

    const errRes = NextResponse.json(
      { error: 'Internal server error', message: process.env.NODE_ENV === 'development' ? (error?.message || 'Error') : 'Configuration generation failed' },
      { status: 500 }
    );
    errRes.headers.set('Cache-Control', 'no-store');
    errRes.headers.set('Pragma', 'no-cache');
    return errRes;
  }
}
